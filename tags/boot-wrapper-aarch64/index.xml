<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Boot-Wrapper-Aarch64 on zlaazlaa's blog</title><link>https://blog.zlaaa.top/tags/boot-wrapper-aarch64/</link><description>Recent content in Boot-Wrapper-Aarch64 on zlaazlaa's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 25 Feb 2025 15:15:11 +0800</lastBuildDate><atom:link href="https://blog.zlaaa.top/tags/boot-wrapper-aarch64/index.xml" rel="self" type="application/rss+xml"/><item><title>ARM Fixed Virtual Platforms (FVPs) + boot-wrapper-aarch64 多核启动</title><link>https://blog.zlaaa.top/p/fvp-wrapper-multi-core-startup/</link><pubDate>Tue, 25 Feb 2025 15:15:11 +0800</pubDate><guid>https://blog.zlaaa.top/p/fvp-wrapper-multi-core-startup/</guid><description>&lt;p>QEMU 支持直接启动具有 Linux Boot Protocal Head 的 kernel 文件，而 FVP 在启动这类 kernel 文件时，就需要借助 ATF 与 u-boot，启动流程较为复杂，而且对调试很不友好。但是 FVP 支持直接启动 ELF 文件，这就需要 boot-wrapper-aarch64 将具有 Linux Boot Protocal Head 的 kernel 文件封装成 ELF 文件，以便 FVP 直接启动 kernel。封装前 kernel 发出的 PSCI 请求由 ATF 响应，封装后由 boot-wrapper-aarch64 响应。&lt;/p>
&lt;p>boot-wrapper-aarch64 在处理多核启动时没有 ATF 那么灵活（详见&lt;a class="link" href="https://blog.zlaaa.top/p/fvp-atf-multi-core-startup/" target="_blank" rel="noopener"
>ARM Fixed Virtual Platforms (FVPs) + boot-wrapper-aarch64 多核启动&lt;/a>），只支持系统 startup 时所有核心一起上电，所以需要对 FVP 添加配置 &lt;code>-C pctl.startup=0.0.0.*&lt;/code> 确保每个核心都上电。&lt;/p>
&lt;p>如果不是所有核心都上电，在初始化阶段会卡在这里：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// wrapper-src/common/init.c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">cpu_init_bootwrapper&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">static&lt;/span> &lt;span class="k">volatile&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">cpu_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">cpu&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">this_cpu_logical_id&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cpu&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">init_bootwrapper&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cpu_next&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">cpu&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">wfe&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">cpu_init_self&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cpu&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cpu_next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cpu&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">dsb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sy&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">sev&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cpu&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cpu_next&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">NR_CPUS&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">wfe&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 卡在这里，因为从核未上电，cpu_next 不会继续增加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">print_string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;All CPUs initialized. Entering kernel...&lt;/span>&lt;span class="se">\r\n\r\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="cpu-亲和性mpidr_el1-寄存器与设备树-cpu-节点的-reg-值">CPU 亲和性、MPIDR_EL1 寄存器与设备树 cpu 节点的 reg 值
&lt;/h2>&lt;p>要想搞懂 FVP 核心启动的四元组配置，首先需要搞懂 CPU 亲和性的相关信息。&lt;/p>
&lt;p>默认状态下，FVP 中 cpu 亲和性四元组中每个数字含义如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一位（chip）&lt;/strong>: 物理 SoC 芯片 ID（通常在单 SoC 系统中是 0）。&lt;/li>
&lt;li>&lt;strong>第二位（cluster）&lt;/strong>: 处理器簇（Cluster）ID，用于标识属于哪一组 CPU 核。&lt;/li>
&lt;li>&lt;strong>第三位（core）&lt;/strong>: 在某个 Cluster 内的 CPU 核 ID。&lt;/li>
&lt;li>&lt;strong>第四位（thread）&lt;/strong>: 超线程 ID（如果处理器支持 SMT，则会有多个线程）。&lt;/li>
&lt;/ul>
&lt;p>这四位与 MPIDR_EL1 寄存器（armv8 是 MPIDR_EL1，armv7 是 MPIDR）中 Aff0、Aff1、Aff2、Aff3 值相对应。&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/fvp-wrapper-multi-core-startup/imgs/MPIDR_EL1-bit-assignments.png"
loading="lazy"
alt="MPIDR_EL1-bit-assignments"
>&lt;/p>
&lt;p>Aff 0、1、2、3 在四元组中对应关系为 {Aff3, Aff2, Aff1, Aff0}，每个四元组唯一标识一个 CPU。&lt;/p>
&lt;p>同样，设备树 cpu 节点中的 reg 值就是从 MPIDR 寄存器中计算得到的，计算方法如下：&lt;/p>
&lt;p>以 ArmV8 64bit 系统为例：&lt;/p>
&lt;ol>
&lt;li>当 &lt;code>#address-cell&lt;/code> property 为 2 时，需要设置 MPIDR_EL1[39:32]（Aff3）到第一个 reg cell 的 reg[7:0]、MPIDR_EL1[23:0]（Aff2、Aff1、Aff0）到第二个 reg cell 的 reg[23:0]。&lt;/li>
&lt;li>当 &lt;code>#address-cell&lt;/code> property 为 1 时，需要设置 MPIDR_EL1[23:0]（Aff2、Aff1、Aff0）到 reg[23:0]；reg 的其他位设置为 0。&lt;/li>
&lt;/ol>
&lt;p>对于 MPIDR_EL1 中的 aff0/1/2/3，对应 FVP 四元组为 (aff3, aff2, aff1, aff0)，reg 值为 &lt;code>&amp;lt;0x aff3&amp;gt; &amp;lt;0x aff2 aff1 aff0&amp;gt;&lt;/code>。&lt;/p>
&lt;p>计算示例（示例中 aff3 均为 0，&lt;code>#address-cell&lt;/code> property 为 1）：&lt;/p>
&lt;ol>
&lt;li>FVP 中亲和性配置为：&lt;code>pctl.CPU-affinities=0.0.0.0, 0.0.1.0, 0.0.2.0, 0.0.3.0&lt;/code>，那么 reg 的值应该是：
&lt;ul>
&lt;li>cpu0: 0x00 00 00 00&lt;/li>
&lt;li>cpu1: 0x00 00 01 00&lt;/li>
&lt;li>cpu2: 0x00 00 02 00&lt;/li>
&lt;li>cpu3: 0x00 00 03 00&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FVP 中亲和性配置为：&lt;code>pctl.CPU-affinities=0.0.0.0, 0.0.0.1, 0.0.1.0, 0.0.1.1, 0.0.1.2, 0.0.1.3&lt;/code>，那么 reg 的值应该是：
&lt;ul>
&lt;li>cpu0: 0x00 00 00 00&lt;/li>
&lt;li>cpu1: 0x00 00 00 01&lt;/li>
&lt;li>cpu2: 0x00 00 01 00&lt;/li>
&lt;li>cpu3: 0x00 00 01 01&lt;/li>
&lt;li>cpu4: 0x00 00 01 02&lt;/li>
&lt;li>cpu5: 0x00 00 01 03&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>Note：0.0.1.3 对应的是 0x103，而不是 0x13，因为 aff0、1、2、3 每个占用 8 bit 空间。&lt;/p>
&lt;h2 id="fvp-中-cpu-亲和性相关启动参数">FVP 中 CPU 亲和性相关启动参数
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;code>-C cluster0.mpidr_layout=0&lt;/code>&lt;/p>
&lt;p>mpidr_layout=0 时，AFF0 为 CPUID，mpidr_layout=1 时，AFF1 为 CPUID。将 mpidr_layout 设置为 0，使得四元组倒数第二位代表 cluster 号，最后一位代表 cluster 内 cpu id，方便计算，FVP 手册中也对 aff 含义进行了描述：&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/fvp-wrapper-multi-core-startup/imgs/fvp-affx-meaning.png"
loading="lazy"
alt="fvp-affx-meaning"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-C pctl.CPU-affinities='0.0.0.0, 0.0.0.1, 0.0.0.2, 0.0.0.3'&lt;/code>&lt;/p>
&lt;p>配置 CPU-affinities，修改默认的 cpu 亲和性，配置 cluster0.mpidr_layout=0 时，计算得到的设备树中 cpu 节点的 reg 值为 0x0 0x1 0x2 0x3，较为直观。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-C pctl.startup=0.0.0.*&lt;/code>&lt;/p>
&lt;p>使用通配符，为确保亲和性为 0.0.0.0, 0.0.0.1, 0.0.0.2, 0.0.0.3 的四个核心在系统启动时全部上电。&lt;/p>
&lt;p>虽然在启动时所有核心都会上电，但只有主核心（primary CPU）会从内核继续执行，其他辅助核心（secondary CPU）则会自旋等待，mailbox 中存入从核的启动地址（即内核的启动地址），此时从核才会启动。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// wrapper-src/common/boot.c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">* Primary CPU finishes platform initialisation and jumps to the kernel.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">* Secondaries are parked, waiting for their mbox to contain a valid address.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">* @cpu: logical CPU number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">* @mbox: location to watch
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">* @invalid: value of an invalid address, 0 or -1 depending on the boot method
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">__noreturn&lt;/span> &lt;span class="nf">first_spin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">cpu&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">mbox&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">invalid&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">cpu&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">addr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">entrypoint&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#ifdef KERNEL_32
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="nf">jump_kernel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">dtb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="nf">jump_kernel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">addr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">dtb&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">mbox&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">invalid&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">spin&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mbox&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">invalid&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">unreachable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 kernel 代码中，主核通过 psci 启动从核（调用函数的参数为 cpu ID 和 kernel entrypoint），boot-wrapper-aarch64 的 psci_cpu_on 函数响应 psci 请求，并将 entry point 存入对应 cpu 的 mailbox 中：&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/fvp-wrapper-multi-core-startup/imgs/kernel-call-psci.png"
loading="lazy"
alt="kernel-call-psci"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-C bp.refcounter.non_arch_start_at_default=1&lt;/code>&lt;/p>
&lt;p>这个参数控制 FVP 处理器核内 generic timer 是否使能，默认是不使能的，如果 generic timer 未打开，Linux 系统就无法正常工作。（现象是进程切换不成功，应该是 generic 无法工作导致中断无法产生）,在使用 boot-wrapper-aarch64 启动时，它不会主动启用 generic timer。&lt;/p>
&lt;p>如果使用 ATF 作为 boot loader，则无需设置此参数，因为 ATF 会在平台初始化时自动启用 generic timer：&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/fvp-wrapper-multi-core-startup/imgs/atf-timer-define.png"
loading="lazy"
alt="atf-timer-define"
>&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/fvp-wrapper-multi-core-startup/imgs/atf-enable-timer.png"
loading="lazy"
alt="atf-enable-timer"
>&lt;/p>
&lt;p>FVP 手册中 timer 的描述：&lt;/p>
&lt;p>&lt;img src="https://blog.zlaaa.top/post/fvp-wrapper-multi-core-startup/imgs/fvp-timer-define.png"
loading="lazy"
alt="fvp-timer-define"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-a cluster0.cpu*=$(path/to/linux-system.axf)&lt;/code>&lt;/p>
&lt;p>这个参数用来指定 FVP 运行的 ELF 文件，星号用于将簇内所有 cpu 的 entry point 改为 ELF 文件的 entry point&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="boot-wrapper-aarch64-使用教程">boot-wrapper-aarch64 使用教程
&lt;/h2>&lt;p>boot-wrapper-aarch64 的使用较为简单，只需要指定一个带有 Linux Boot Protocal Head 的 kernel 路径和该 kernel dtb 的路径即可。编译产物就是 ELF 格式的 linux-system.axf，示例如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">git clone git://git.kernel.org/pub/scm/linux/kernel/git/mark/boot-wrapper-aarch64.git
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">cd&lt;/span> boot-wrapper-aarch64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">autoreconf -i
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">./configure --enable-psci --enable-gicv3 --with-kernel-image&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>kernel_image&lt;span class="k">)&lt;/span> --with-dtb&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>kernel_dtb&lt;span class="k">)&lt;/span> --host&lt;span class="o">=&lt;/span>aarch64-linux-gnu
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">make
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="总结">总结
&lt;/h2>&lt;p>本文介绍了如何在 ARM Fixed Virtual Platforms (FVPs) 上使用 boot-wrapper-aarch64 实现多核启动。通过将具有 Linux Boot Protocal Head 的 kernel 文件封装成 ELF 文件，可以简化启动流程并提高调试效率。我们详细讨论了 CPU 亲和性、MPIDR_EL1 寄存器与设备树 cpu 节点的 reg 值的关系，以及 FVP 中相关启动参数的配置。最后，提供了 boot-wrapper-aarch64 的使用教程，帮助读者快速上手。&lt;/p>
&lt;h2 id="参考文献">参考文献
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/scorp2kk/atf/blob/master/docs/reset-design.md" target="_blank" rel="noopener"
>ARM Trusted Firmware Reset Design&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://community.arm.com/oss-platforms/w/docs/645/guide-to-run-and-debug-linux-software-stack-on-arm-fixed-virtual-platforms" target="_blank" rel="noopener"
>Guide to Run and Debug Linux Software Stack on ARM Fixed Virtual Platforms&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.csdn.net/M0XFFF/article/details/127108259" target="_blank" rel="noopener"
>ARM Development Studio 2021 FVP调试Linux内核代码&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://aijishu.com/a/1060000000497694" target="_blank" rel="noopener"
>SOC的多核启动流程详解&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/537381492" target="_blank" rel="noopener"
>linux cpu管理（三） psci启动&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>