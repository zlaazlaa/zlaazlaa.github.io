[{"content":"QEMU 支持直接启动具有 Linux Boot Protocal Head 的 kernel 文件，而 FVP 在启动这类 kernel 文件时，就需要借助 ATF 与 u-boot，启动流程较为复杂，而且对调试很不友好。但是 FVP 支持直接启动 ELF 文件，这就需要 boot-wrapper-aarch64 将具有 Linux Boot Protocal Head 的 kernel 文件封装成 ELF 文件，以便 FVP 直接启动 kernel。封装前 kernel 发出的 PSCI 请求由 ATF 响应，封装后由 boot-wrapper-aarch64 响应。\nboot-wrapper-aarch64 在处理多核启动时没有 ATF 那么灵活（详见ARM Fixed Virtual Platforms (FVPs) + boot-wrapper-aarch64 多核启动），只支持系统 startup 时所有核心一起上电，所以需要对 FVP 添加配置 -C pctl.startup=0.0.0.* 确保每个核心都上电。\n如果不是所有核心都上电，在初始化阶段会卡在这里：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // wrapper-src/common/init.c void cpu_init_bootwrapper(void) { static volatile unsigned int cpu_next = 0; unsigned int cpu = this_cpu_logical_id(); if (cpu == 0) init_bootwrapper(); while (cpu_next != cpu) wfe(); cpu_init_self(cpu); cpu_next = cpu + 1; dsb(sy); sev(); if (cpu != 0) return; while (cpu_next != NR_CPUS) wfe(); // 卡在这里，因为从核未上电，cpu_next 不会继续增加 print_string(\u0026#34;All CPUs initialized. Entering kernel...\\r\\n\\r\\n\u0026#34;); } CPU 亲和性、MPIDR_EL1 寄存器与设备树 cpu 节点的 reg 值 要想搞懂 FVP 核心启动的四元组配置，首先需要搞懂 CPU 亲和性的相关信息。\n默认状态下，FVP 中 cpu 亲和性四元组中每个数字含义如下：\n第一位（chip）: 物理 SoC 芯片 ID（通常在单 SoC 系统中是 0）。 第二位（cluster）: 处理器簇（Cluster）ID，用于标识属于哪一组 CPU 核。 第三位（core）: 在某个 Cluster 内的 CPU 核 ID。 第四位（thread）: 超线程 ID（如果处理器支持 SMT，则会有多个线程）。 这四位与 MPIDR_EL1 寄存器（armv8 是 MPIDR_EL1，armv7 是 MPIDR）中 Aff0、Aff1、Aff2、Aff3 值相对应。\nAff 0、1、2、3 在四元组中对应关系为 {Aff3, Aff2, Aff1, Aff0}，每个四元组唯一标识一个 CPU。\n同样，设备树 cpu 节点中的 reg 值就是从 MPIDR 寄存器中计算得到的，计算方法如下：\n以 ArmV8 64bit 系统为例：\n当 #address-cell property 为 2 时，需要设置 MPIDR_EL1[39:32]（Aff3）到第一个 reg cell 的 reg[7:0]、MPIDR_EL1[23:0]（Aff2、Aff1、Aff0）到第二个 reg cell 的 reg[23:0]。 当 #address-cell property 为 1 时，需要设置 MPIDR_EL1[23:0]（Aff2、Aff1、Aff0）到 reg[23:0]；reg 的其他位设置为 0。 对于 MPIDR_EL1 中的 aff0/1/2/3，对应 FVP 四元组为 (aff3, aff2, aff1, aff0)，reg 值为 \u0026lt;0x aff3\u0026gt; \u0026lt;0x aff2 aff1 aff0\u0026gt;。\n计算示例（示例中 aff3 均为 0，#address-cell property 为 1）：\nFVP 中亲和性配置为：pctl.CPU-affinities=0.0.0.0, 0.0.1.0, 0.0.2.0, 0.0.3.0，那么 reg 的值应该是： cpu0: 0x00 00 00 00 cpu1: 0x00 00 01 00 cpu2: 0x00 00 02 00 cpu3: 0x00 00 03 00 FVP 中亲和性配置为：pctl.CPU-affinities=0.0.0.0, 0.0.0.1, 0.0.1.0, 0.0.1.1, 0.0.1.2, 0.0.1.3，那么 reg 的值应该是： cpu0: 0x00 00 00 00 cpu1: 0x00 00 00 01 cpu2: 0x00 00 01 00 cpu3: 0x00 00 01 01 cpu4: 0x00 00 01 02 cpu5: 0x00 00 01 03 Note：0.0.1.3 对应的是 0x103，而不是 0x13，因为 aff0、1、2、3 每个占用 8 bit 空间。\nFVP 中 CPU 亲和性相关启动参数 -C cluster0.mpidr_layout=0\nmpidr_layout=0 时，AFF0 为 CPUID，mpidr_layout=1 时，AFF1 为 CPUID。将 mpidr_layout 设置为 0，使得四元组倒数第二位代表 cluster 号，最后一位代表 cluster 内 cpu id，方便计算，FVP 手册中也对 aff 含义进行了描述：\n-C pctl.CPU-affinities='0.0.0.0, 0.0.0.1, 0.0.0.2, 0.0.0.3'\n配置 CPU-affinities，修改默认的 cpu 亲和性，配置 cluster0.mpidr_layout=0 时，计算得到的设备树中 cpu 节点的 reg 值为 0x0 0x1 0x2 0x3，较为直观。\n-C pctl.startup=0.0.0.*\n使用通配符，为确保亲和性为 0.0.0.0, 0.0.0.1, 0.0.0.2, 0.0.0.3 的四个核心在系统启动时全部上电。\n虽然在启动时所有核心都会上电，但只有主核心（primary CPU）会从内核继续执行，其他辅助核心（secondary CPU）则会自旋等待，mailbox 中存入从核的启动地址（即内核的启动地址），此时从核才会启动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // wrapper-src/common/boot.c /** * Primary CPU finishes platform initialisation and jumps to the kernel. * Secondaries are parked, waiting for their mbox to contain a valid address. * * @cpu: logical CPU number * @mbox: location to watch * @invalid: value of an invalid address, 0 or -1 depending on the boot method */ void __noreturn first_spin(unsigned int cpu, unsigned long *mbox, unsigned long invalid) { if (cpu == 0) { unsigned long addr = (unsigned long)\u0026amp;entrypoint; #ifdef KERNEL_32 jump_kernel(addr, 0, ~0, (unsigned long)\u0026amp;dtb, 0); #else jump_kernel(addr, (unsigned long)\u0026amp;dtb, 0, 0, 0); #endif } else { *mbox = invalid; spin(mbox, invalid); } unreachable(); } 在 kernel 代码中，主核通过 psci 启动从核（调用函数的参数为 cpu ID 和 kernel entrypoint），boot-wrapper-aarch64 的 psci_cpu_on 函数响应 psci 请求，并将 entry point 存入对应 cpu 的 mailbox 中：\n-C bp.refcounter.non_arch_start_at_default=1\n这个参数控制 FVP 处理器核内 generic timer 是否使能，默认是不使能的，如果 generic timer 未打开，Linux 系统就无法正常工作。（现象是进程切换不成功，应该是 generic 无法工作导致中断无法产生）,在使用 boot-wrapper-aarch64 启动时，它不会主动启用 generic timer。\n如果使用 ATF 作为 boot loader，则无需设置此参数，因为 ATF 会在平台初始化时自动启用 generic timer：\nFVP 手册中 timer 的描述：\n-a cluster0.cpu*=$(path/to/linux-system.axf)\n这个参数用来指定 FVP 运行的 ELF 文件，星号用于将簇内所有 cpu 的 entry point 改为 ELF 文件的 entry point\nboot-wrapper-aarch64 使用教程 boot-wrapper-aarch64 的使用较为简单，只需要指定一个带有 Linux Boot Protocal Head 的 kernel 路径和该 kernel dtb 的路径即可。编译产物就是 ELF 格式的 linux-system.axf，示例如下：\n1 2 3 4 5 git clone git://git.kernel.org/pub/scm/linux/kernel/git/mark/boot-wrapper-aarch64.git cd boot-wrapper-aarch64 autoreconf -i ./configure --enable-psci --enable-gicv3 --with-kernel-image=$(kernel_image) --with-dtb=$(kernel_dtb) --host=aarch64-linux-gnu make 总结 本文介绍了如何在 ARM Fixed Virtual Platforms (FVPs) 上使用 boot-wrapper-aarch64 实现多核启动。通过将具有 Linux Boot Protocal Head 的 kernel 文件封装成 ELF 文件，可以简化启动流程并提高调试效率。我们详细讨论了 CPU 亲和性、MPIDR_EL1 寄存器与设备树 cpu 节点的 reg 值的关系，以及 FVP 中相关启动参数的配置。最后，提供了 boot-wrapper-aarch64 的使用教程，帮助读者快速上手。\n参考文献 ARM Trusted Firmware Reset Design Guide to Run and Debug Linux Software Stack on ARM Fixed Virtual Platforms ARM Development Studio 2021 FVP调试Linux内核代码 SOC的多核启动流程详解 linux cpu管理（三） psci启动 ","date":"2025-02-25T15:15:11+08:00","permalink":"https://blog.zlaaa.top/p/fvp-wrapper-multi-core-startup/","title":"ARM Fixed Virtual Platforms (FVPs) + boot-wrapper-aarch64 多核启动"},{"content":"ATF 的两种多核启动流程 ATF 支持两种多核启动流程：\nSoC 启动时仅有一个核心上电 SoC 启动时所有核心同时上电 这两种启动方式由以下宏定义控制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // atf-src/aarch64/bl1_entrypoint.S func bl1_entrypoint /* --------------------------------------------------------------------- * If the reset address is programmable then bl1_entrypoint() is * executed only on the cold boot path. Therefore, we can skip the warm * boot mailbox mechanism. * --------------------------------------------------------------------- */ el3_entrypoint_common\t\\ _init_sctlr=1\t\\ _warm_boot_mailbox=!PROGRAMMABLE_RESET_ADDRESS\t\\ _secondary_cold_boot=!COLD_BOOT_SINGLE_CPU\t\\ // 注意这里 _init_memory=1\t\\ _init_c_runtime=1\t\\ _exception_vectors=bl1_exceptions\t\\ _pie_fixup_size=0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // atf-src/include/arch/aarch64/el3_common_macros.S .if \\_secondary_cold_boot /* ------------------------------------------------------------- * Check if this is a primary or secondary CPU cold boot. * The primary CPU will set up the platform while the * secondaries are placed in a platform-specific state until the * primary CPU performs the necessary actions to bring them out * of that state and allows entry into the OS. * ------------------------------------------------------------- */ bl\tplat_is_my_cpu_primary cbnz\tw0, do_primary_cold_boot /* This is a cold boot on a secondary CPU */ bl\tplat_secondary_cold_boot_setup /* plat_secondary_cold_boot_setup() is not supposed to return */ bl\tel3_panic do_primary_cold_boot: .endif /* _secondary_cold_boot */ 单核上电 当编译 ATF 时，如果将 COLD_BOOT_SINGLE_CPU 设置为 1，则采用第一种方式：冷启动时只有一个核心运行，secondary_cold_boot 宏不会被编译，直接执行 do_primary_cold_boot。此时，从核需要通过内核发出 PSCI 请求，由 ATF 处理后才能启动。下图展示了内核调用 PSCI 并由 ATF 响应的过程：\n为 FVP 启动参数添加追踪插件（\u0026ndash;plugin FVP-PATH/Base_RevC_AEMvA_pkg/plugins/Linux64_armv8l_GCC-9.3/TarmacTrace.so）后，可以观察到 u-boot 启动时仍然只有单核（cpu0）运行，其他核心只有在进入 kernel 后才被唤醒：\n多核上电 如果将 COLD_BOOT_SINGLE_CPU 设置为 0，则采用第二种方式：冷启动时所有核心同时上电，主核执行 do_primary_cold_boot，从核执行 plat_secondary_cold_boot_setup。在 plat_secondary_cold_boot_setup 函数中，从核会进入低功耗状态，等待 kernel 通过 PSCI 请求唤醒并写入启动地址，然后通过检查 mailbox 是否为非零值来完成唤醒过程：\n1 2 3 4 5 6 7 8 9 10 11 // atf-src/plat/arm/board/fvp/aarch64/fvp_helpers.S mov_imm\tx0, PLAT_ARM_TRUSTED_MAILBOX_BASE /* Wait until the entrypoint gets populated */ poll_mailbox: ldr\tx1, [x0] cbz\tx1, 1f br\tx1 1: wfe b\tpoll_mailbox 具体采用哪种启动方式取决于编译 ATF 时 COLD_BOOT_SINGLE_CPU 的配置值。在 ATF 的默认设置中，该值通常为 0（定义于 atf-src/make_helpers/defaults.mk），各平台可根据需要在各自的 platform.mk 中进行覆盖。在 FVP 的配置中，COLD_BOOT_SINGLE_CPU 也被设置为 0。\nFVP 配置启动时核心上电情况 FVP 还允许配置启动时为哪些核心上电，这与 COLD_BOOT_SINGLE_CPU 的不同取值组合，会产生不同的启动行为，如下表所示：\npctl.startup=0.0.0.0（仅主核上电） pctl.startup=0.0.0.*（所有核心上电） COLD_BOOT_SINGLE_CPU=0 ✅ 正常启动 ✅ 正常启动 COLD_BOOT_SINGLE_CPU=1 ✅ 正常启动 ❌ 无法启动 当 COLD_BOOT_SINGLE_CPU=1 且 pctl.startup=0.0.0.* 时，由于 do_primary_cold_boot 函数被多个核心重复执行，系统无法正常启动。\n而在 COLD_BOOT_SINGLE_CPU=0 且 pctl.startup=0.0.0.0 的情况下，系统可以通过 PSCI 接口唤醒尚未上电的次核：\n","date":"2025-02-25T14:10:15+08:00","permalink":"https://blog.zlaaa.top/p/fvp-atf-multi-core-startup/","title":"ARM Fixed Virtual Platforms (FVPs) + ATF 多核启动"},{"content":"在使用 VMware Fusion 创建虚拟机时，分配给虚拟机的硬盘空间并不会立即占用宿主机的空间，而是根据虚拟机的实际需求动态申请。\n经过长时间使用，VMware Fusion 占用宿主机的硬盘空间可能会大于虚拟机实际使用的空间。这是因为 VMware Fusion 只会向宿主机申请空间，而不会主动释放。此时，需要借助 VMware Tools 手动释放硬盘空间。\n安装 VMware Tools 可以参考官方文档，或者也可以使用 apt 安装：\n1 sudo apt-get install open-vm-tools-desktop 使用 VMware Tools Shrink 硬盘 运行以下 shell 脚本，释放虚拟机未使用的磁盘空间：\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash disk_list=`sudo vmware-toolbox-cmd disk list` for disk in ${disk_list} do sudo vmware-toolbox-cmd disk wipe ${disk} done sudo vmware-toolbox-cmd disk shrinkonly ","date":"2025-02-21T16:08:17+08:00","permalink":"https://blog.zlaaa.top/p/shrink-vmware-disk/","title":"降低 VMware Fusion 的硬盘占用"},{"content":"前言 最近在为 Hypervisor 适配新平台 ARM Fixed Virtual Platforms (FVPs)，具体架构是 FVP + Hypervisor + Guest OS，发现 Guest OS 无法启动。然而，QEMU + Hypervisor + Guest OS 一切正常。进一步调试后发现，在 FVP 场景下，Guest OS 中所有未初始化的全局变量均不是零值，导致默认它们为零的代码出现错误。\n根据 C 标准，未初始化的全局变量应默认置零：\n如果一个具有自动存储周期的对象不被显式地初始化，那么其值是不确定的。如果具有静态或线程存储周期的一个对象不被显式初始化，那么\n—— 如果它具有指针类型，那么它被初始化为一个空指针；\n—— 如果它具有算术类型，那么它被初始化为（正的或负的）零；\n—— 如果它是一个聚合类型，那么每个成员被初始化（递归地），根据以上规则，并且任何填充被初始化为零比特；\n—— 如果它是一个联合体，那么第一个命名成员被（递归地）初始化，根据以上规则，并且填充被初始化为零比特。\n问题分析 对于 ELF 文件来说，存储变量的叫数据段。数据段分为 .data 段和 .bss 段，其中 .data 段存储已经初始化的全局变量和静态变量，.bss 段存储未经初始化的全局变量。\n.bss 段属于 nload 段，在镜像中不占空间，镜像被加载后，才会映射到内存，此时 .bss 段的内容继承自被映射的内存区域。\n很不幸，我运行的 Guest OS 并没有清零自己的 .bss 段，而且 Hypervisor 的实现也比较简单，仅仅是做了以下内存映射：GPA -\u0026gt; HVA -\u0026gt; HPA，将自身的 memory 区域一一映射给 Guest OS，也没有对这部分内存做置零处理。\n但是为什么 QEMU + Hypervisor + Guest OS 正常运行，而 FVP + Hypervisor + Guest OS 不行呢？\n这是因为 QEMU 提供的可用内存的默认值都是 0： 而 FVP 提供的可用内存区域默认值是 0xcfdfdfdf 与 0xdfdfdfcf 的循环： 具体见 FVP 的 params：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 FVP_Base_RevC-2xAEMvA --list-params | grep fill bp.dmc.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dmc.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dmc_phy.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dmc_phy.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_local_dap_rom.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_local_dap_rom.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_ram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_ram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_usb.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.dummy_usb.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.ns_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.ns_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.psram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.psram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rl_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rl_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rt_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.rt_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.s_dram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.s_dram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureDRAM.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureDRAM.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureSRAM.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.secureSRAM.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.sram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.sram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.vram.fill1=3755990991 # (int , init-time) default = \u0026#39;0xdfdfdfcf\u0026#39; : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern bp.vram.fill2=3487555551 # (int , init-time) default = \u0026#39;0xcfdfdfdf\u0026#39; : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern cluster0.ext_abort_fill_data=18302063723721653757 # (int , init-time) default = \u0026#39;0xfdfdfdfcfcfdfdfd\u0026#39; : Returned data, if external aborts are asynchronous cluster0.randomize_unknowns_at_reset=0 # (bool , init-time) default = \u0026#39;0\u0026#39; : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset cluster0.register_reset_data=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill register bits when they become UNKNOWN at reset. cluster0.register_reset_data_hi=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset. cluster0.scramble_unknowns_at_reset=1 # (bool , init-time) default = \u0026#39;1\u0026#39; : Will fill in unknown bits in registers at reset with register_reset_data cluster0.unpred_extdbg_unknown_bits=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR. cluster1.ext_abort_fill_data=18302063723721653757 # (int , init-time) default = \u0026#39;0xfdfdfdfcfcfdfdfd\u0026#39; : Returned data, if external aborts are asynchronous cluster1.randomize_unknowns_at_reset=0 # (bool , init-time) default = \u0026#39;0\u0026#39; : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset cluster1.register_reset_data=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill register bits when they become UNKNOWN at reset. cluster1.register_reset_data_hi=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset. cluster1.scramble_unknowns_at_reset=1 # (bool , init-time) default = \u0026#39;1\u0026#39; : Will fill in unknown bits in registers at reset with register_reset_data cluster1.unpred_extdbg_unknown_bits=0 # (int , init-time) default = \u0026#39;0x0\u0026#39; : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR. 以上配置项显示了 FVP 可以对如下内存区域进行配置：\nbp.dmc.* 和 bp.dmc_phy.*\n表示 DRAM Controller（内存控制器）及其物理层相关的内存填充值。\n用途：初始化内存控制器的地址空间，可能包括配置寄存器、缓冲区等。\nbp.ns_dram.*\n表示 Non-Secure DRAM（非安全动态随机存取存储器）的填充值。\n用途：初始化普通内存区域（非安全内存），模拟器启动时填充的默认模式。\nbp.rl_dram.* 和 bp.rt_dram.*\n表示 Real-time Left 和 Real-time Right DRAM，分别对应系统的左右两部分实时内存。\n用途：通常用于模拟分区的实时内存。\nbp.s_dram.* 和 bp.secureDRAM.*\n表示 Secure DRAM（安全动态随机存取存储器）的填充值。\n用途：存储安全相关数据，例如密钥、加密缓存等。\nbp.psram.*\n表示 PSRAM（伪静态随机存取存储器）的填充值。\n用途：嵌入式设备中用于提高性能的混合型存储器。\nbp.sram.* 和 bp.secureSRAM.*\n表示 SRAM（静态随机存取存储器）和 Secure SRAM 的填充值。\n用途：SRAM 通常用于高速缓存或快速存储，Secure SRAM 用于安全用途。\nbp.vram.*\n表示 VRAM（视频随机存取存储器）的填充值。\n用途：用于存储图形数据或显示缓冲区。\nbp.dummy_*\n表示模拟器中用于占位或辅助调试的虚拟内存区域（如 dummy_ram、dummy_usb）。\n用途：不对应真实硬件，而是提供测试或开发的功能。\n关于 fill1 和 fill2，如果他们的值分别是 A 和 B，那么 FVP 的对应内存区间的值就会是 ABABABABABABABABABAB\u0026hellip;\u0026hellip; 的循环。\n如果不对 FVP 内存初始值进行配置，.bss 段“展开”后的内容就是默认的 0xcfdfdfdfdfdfdfcf，这也是为什么 debug 过程中看到所有未经初始化的值都是 0xcfdfdfdfdfdfdfcf。\n对于我这个例子，Guest OS 镜像是嵌入 Hypervisor 镜像中的，经过测试，发现 Hypervisor 镜像所在内存区间为 bp.s_dram，为 FVP 添加如下启动参数后，Guest OS 可以正常启动：\n1 2 -C bp.s_dram.fill1=0x0 \\ -C bp.s_dram.fill2=0x0 PS:\n关于为什么是 bp.s_dram，FVP 手册中可以找到一些蛛丝马迹。其实我是挨个试的\nHypervisor 镜像所在内存区间的安全属性是 P 对于P，默认的处理策略是安全访问和非安全访问全部拒绝，我猜测拒绝非安全访问的区间，都在 bp.s_dram 的配置范围内。但是我也查看了一些N/S区间，并不是所有的N/S区间都在 bs.s_dram 的配置范围内。如果有知道的同学可以在评论区⬇️讨论下。 ","date":"2025-01-06T21:01:07+08:00","permalink":"https://blog.zlaaa.top/p/global-val-is-not-zero-in-fvp/","title":"ARM Fixed Virtual Platforms (FVPs)中运行 Hypervisor，Guest OS 的全局变量没有置零"},{"content":"前言 最近在 Debug U-boot 的过程中遇到了无法打断点的问题，找了好久才确定是 U-Boot 自身做 relocate 造成的，其实这个问题在 U-Boot 官方文档中有提及，所以这里做一下记录。\n减少编译优化与禁用链接时间优化 为了方便调试，防止有些变量被优化掉导致 gdb 中看不到，在 U-Boot 的 defconfig 中添加如下配置\n1 2 CONFIG_CC_OPTIMIZE_FOR_DEBUG=y CONFIG_LTO=n 开启 U-Boot Debug 日志输出 修改 u-boot/include/log.h\nU-Boot relocate 介绍 U-Boot在启动阶段会将自己的地址做重定向，一开始 add-symbol-file 时没有加地址也可以正常使用，是因为在没有 relocate 前，U-Boot 的地址与符号表中的一致。执行 relocate (u-boot/arch/arm/lib/relocate_64.S) 操作后，U-Boot 的运行地址发生变化，原来导入的符号表就不能用了，需要将符号表导入到新的地址。\nU-Boot Debug 过程 第一步：添加符号表（无需指定地址） 1 add-symbol-file ./workdir/src/u-boot/u-boot 第二步：在 relocate_done 函数处打断点并运行 u-boot 1 2 3 4 5 6 7 (gdb) break relocate_done Breakpoint 1 at 0x88002e8c: file arch/arm/lib/relocate_64.S, line 80. (gdb) c Continuing. Breakpoint 1, relocate_code () at arch/arm/lib/relocate_64.S:80 80 switch_el x1, 3f, 2f, 1f 第三步：查看 U-Boot 重定向后的运行地址 1 2 (gdb) p/x (*(struct global_data*)$x18)-\u0026gt;relocaddr $2 = 0xfef1e000 注意：\n这一步中，具体的寄存器见表，我这里是 arm64 架构的，所以结构体地址存储在 x18 寄存器中：\nArchitecture Register arc r25 arm r9 arm64 x18 m68k d7 microblaze r31 mips k0 nios2 gp powerpc r2 riscv gp sh r13 第四步：删除原先符号表 1 2 3 (gdb) symbol-file Discard symbol table? (y or n) y No symbol file now. 第五步：将符号表加载到重定向后的地址 1 2 3 4 5 (gdb) add-symbol-file ./workdir/src/u-boot/u-boot 0xfef1e000 add symbol table from file \u0026#34;./workdir/src/u-boot/u-boot\u0026#34; at .text_addr = 0xfef1e000 (y or n) y Reading symbols from ./workdir/src/u-boot/u-boot... 注意：\n是否重新导入符号表取决于打断点的位置，如果在 relocate 操作前则不需要，反之则需要。\n","date":"2025-01-05T19:03:20+08:00","permalink":"https://blog.zlaaa.top/p/debug-u-boot/","title":"如何 Debug U-Boot"},{"content":"概述 在调试 ARM FVP 模型时，直接通过 GDB 连接是行不通的。虽然 ARM 官方为付费版 Fast Model 提供了 GDB 插件，但免费版 Base Model 并不支持该功能。取而代之，Base Model 提供了一种名为 Iris Debug Server 的 Python Debug API。因此，要使用 GDB 调试 Base FVP，需要通过中间工具进行协议转译。\n本文将介绍如何使用 lite-cornea 工具简化 FVP 的调试过程。\n调试工具选择 目前找到的 Iris-to-GDB 转译工具有以下两个：\nlite-cornea 基于 Rust，可直接嵌入 GDB 终端，命令兼容性较好。 iris-gdb-wrapper 基于 Python，需要先运行后端服务，然后以远程模式连接 GDB。 经测试，lite-cornea 支持更多 GDB 命令（如 dump、restore），推荐使用。iris-gdb-wrapper 在使用这些命令时有一些 bug，不能正常导入导出内存。\n安装 lite-cornea 安装 Rust 环境 运行以下命令快速安装：\n1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装完成后，重启终端并验证 Rust：\n1 cargo --version 编译并安装 lite-cornea 1 2 3 4 5 git clone https://github.com/Linaro/lite-cornea.git cd lite-cornea cargo build sudo cp target/debug/cornea /usr/bin/ cornea --help 使用 GDB + lite-cornea 调试 FVP 配置 FVP 启动参数 在启动 FVP 时，添加 -I 参数以启用 Iris Debug Server。\n编写 GDB 调试脚本 创建一个 GDB 启动脚本（例如 debug.sh）并添加以下内容：\n1 2 3 4 #!/usr/bin/env -S gdb -q -ix set architecture aarch64 add-symbol-file /path/to/your/symbol/file target remote | cornea gdb-proxy component.FVP_Base_RevC_2xAEMvA.cluster0.cpu0 启动调试 运行 FVP 后，执行调试脚本：\n1 sh debug.sh 脚本执行成功后，会自动进入 GDB 调试终端，默认停在 0x0 的位置，方便后续调试：\n1 2 3 4 5 6 7 $ ./gdb-connect-fvp2.sh The target architecture is set to \u0026#34;aarch64\u0026#34;. warning: No executable has been specified and target does not support determining executable automatically. Try using the \u0026#34;file\u0026#34; command. 0x0000000000000000 in ?? () (gdb) 注意：\ncornea 参数中的 FVP_Base_RevC_2xAEMvA 需替换为实际运行的 FVP 模型名称，与 FVP 的二进制文件名（例如 FVP_Base_RevC-2xAEMvA）相似。 如果不确定模型名称，请参考 ARM FVP 文档 中的模型目录：\n","date":"2025-01-05T15:59:16+08:00","permalink":"https://blog.zlaaa.top/p/debug-fvp-via-gdb/","title":"使用 lite-cornea 调试 ARM Fixed Virtual Platforms (FVPs)"},{"content":"在使用 VS Code 打开包含大量文件的 C/C++ 项目时，经常会遇到 CPU 占用过高的问题。尤其是当同时打开多个 VS Code 窗口时，CPU 占用会成倍增加，有时甚至高达 400%，几乎完全占满 4 个核心。经排查，这是由于 C/C++ 插件在分析代码，而我的项目中包含 Linux 源码、u-boot 源码、buildroot 源码等大型代码库，导致插件一直在进行代码分析，进而引发系统卡顿。\n解决方法：排除目录 可以通过修改 settings.json 文件，为 C/C++ 插件排除特定目录。以下是我的配置示例：\n1 2 3 4 5 6 7 8 \u0026#34;C_Cpp.files.exclude\u0026#34;: { \u0026#34;**/.git\u0026#34;: true, \u0026#34;**/workdir\u0026#34;: true, \u0026#34;**/wkdir\u0026#34;: true, \u0026#34;**/build\u0026#34;: true, \u0026#34;**/bin\u0026#34;: true, \u0026#34;/PROJECT_ROOT/COMPONENT/ANONYMIZED\u0026#34;: true, } 值得注意的是，配置的是C_Cpp.files.exclude而非files.exclude，如果配置成后者，这些目录会被 VS Code 的文件资源管理器排除，跟消失了一样。 配置说明 **/workdir 和 **/wkdir：我的项目中，大量外部源码存储在这两个目录中。\n/PROJECT_ROOT/COMPONENT/ANONYMIZED：该目录是 C/C++ 插件缓存代码分析结果的存储位置，排除它可以防止插件重复递归分析自身的缓存文件而产生死循环。\n参考 有关插件缓存目录（/PROJECT_ROOT/COMPONENT/ANONYMIZED）的更多讨论，可以参考 GitHub Issue。\n","date":"2024-12-04T18:27:07+08:00","permalink":"https://blog.zlaaa.top/p/fix-vscode-cpptools-cpu-usage-too-high/","title":"VS Code C/C++ 插件 cpptools CPU 占用过高"},{"content":"Linenoise 简介 Linenoise 是一个轻量级的行编辑库，适用于需要简单命令行编辑功能的应用程序，可以用它快速完成 shell 的开发。它支持多平台，并且与 GNU Readline 库相比，Linenoise 的代码更加简洁，易于集成和使用。\n转义序列显示异常 在移植 Linenoise 之后，发现此时 Shell 存在一个 Bug，长按某些按键时会输出[D、[A、D、A之类的乱码，例如，长按左右方向键时会输出如下字符，并且出现的时机不规律。\n分析 按理来说按下左右方向键不应输出任何字符，所以肯定和左右方向键的转义序列有关，一些按键的转义序列如下：\n上箭头键：ESC [ A 或 \\x1b[A 下箭头键：ESC [ B 或 \\x1b[B 左箭头键：ESC [ D 或 \\x1b[D 右箭头键：ESC [ C 或 \\x1b[C 删除键（Del）：ESC [ 3 ~ 或 \\x1b[3~ 查看 Linenoise 源码发现，处理逻辑为逐个尝试输入ESC、[、A/B/C/D/数字～\n问题就出在逐个输入这里，如果输入采用的串口不稳定（我这里是 pl011），快速输入就会导致读取失败（Linenoise 读取时串口缓冲区还没有数据），这里直接 break 就会导致状态机跳出当前状态，使得ESC、[、A三者被拆开，并没有当作一个上箭头键来处理。\n解决方案 解决方案也很简单，就是将 break 改成循环读入，如果读取失败就重新尝试。\n1 2 3 4 5 while (1) { if (read(l-\u0026gt;ifd, seq, 1) != -1) { break; } } ","date":"2024-11-07T17:10:33+08:00","permalink":"https://blog.zlaaa.top/p/bug-while-inputing-escape-sequences-in-linenoise/","title":"使用Linenoise时转义序列显示异常"},{"content":"在使用 VMware Fusion 时，可能会遇到 Ubuntu 虚拟机磁盘空间不足的问题。本文将介绍如何在 VMware Fusion 中扩展 Ubuntu 虚拟机的磁盘容量，以确保系统能够正常运行并满足更多存储需求。\n在 VMware Fusion 中增加 Ubuntu 的硬盘分配空间 首先将 Ubuntu 虚拟机关机，然后在 VMware Fusion 中配置硬盘空间。\n在 Ubuntu 中分配新增空间 此时新增的空间只是未分配空间，并没有真正用于 Ubuntu，磁盘大小并没有改变。\n可以使用 GParted 图形化分区编辑工具对硬盘进行分配。\n如图所示，新增的 130G 空间尚未分配。\n首先点击原有的磁盘空间，再点击 resize 按钮，将其扩大至最大。\n完成后可以看到根目录磁盘空间已经扩大至 150G。\n","date":"2024-10-19T16:18:16+08:00","permalink":"https://blog.zlaaa.top/p/expand-ubuntu-disk-capacity/","title":"在 VMware Fusion 中扩展 Ubuntu 虚拟机磁盘容量"},{"content":"Hugo 是一个用 Go 语言编写的静态网站生成器，以速度快、易用性高和灵活性强而著称。Hugo 通过结合 Markdown 文件和模板，能够快速生成静态网页，适用于博客、文档和个人网站等场景。它支持多种主题和插件，能够轻松部署到 GitHub Pages 等平台，非常适合开发者和内容创作者使用。\nHugo 提供了许多主题，我使用的是 Hugo Stack。在部署过程中，如果使用 Hugo 官方文档，即使已经取消 draft 标记，也无法显示新建的文章：Issue。可以直接使用 Hugo Stack 的官方模板 来解决这个问题。\n使用模板创建仓库 创建的仓库名为username.github.io，username为自己的github用户名。\n将仓库克隆到本地并安装 Hugo 拓展版 Linux 1 sudo apt install hugo Mac OS 1 brew install hugo Windows 1 choco install hugo-extended 或者直接下载二进制\n新增文章并发布 1 hugo new content content/posts/my-first-post.md 使用此命令创建的文章有 draft 标记，Hugo 在默认情况下并不会发布带有此标记的文章，需要添加 -D 或 --buildDrafts 参数。\n确认发布后，将 draft 标记改为 false，提交 commit 至 GitHub 即可。\nGitHub Actions 自动化发布 Hugo Stack 模板仓库内包含 deploy.yml、update-theme.yml 两个 GitHub Workflow 文件，分别负责自动化发布和更新主题版本，详见 Hugo Stack GitHub Workflows。仓库的更新会触发 GitHub Actions 进行自动化发布。\nGitHub Pages 配置 deploy.yml 会将博客发布到 gh-pages 分支。\n所以需要在仓库设置中更改 Pages 的分支为 gh-pages。\n如果没有 gh-pages 选项，可能 GitHub Actions 还在构建中，等待构建完毕即可。\n自定义域名 发布完毕后，可以通过 https://username.github.io 访问，也可以配置自定义域名。\n只需要将你的域名 CNAME 指向 username.github.io，并在仓库设置中添加 Custom domain，等待 DNS 验证成功后，即可使用自定义的域名访问刚刚发布的博客。\n同时也可以配置强制 https 以增强安全性。\n添加 Giscus 评论系统 Hugo支持多种评论系统，我选择了 Giscus。Giscus 会将所有的评论保存至Github Discussion，无需担心数据丢失的问题。\n安装 Giscus App 至当前仓库 Giscus App\n开启仓库的 Discussion 功能 在 Giscus 官网获取配置信息 在 Hugo 配置文件中启用 Giscus 评论系统 配置信息与上一步在 Giscus 官网获取的信息相对应，配置文件示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 # config/_defconfig/params.toml [comments.giscus] repo = \u0026#34;zlaazlaa/zlaazlaa.github.io\u0026#34; repoId = \u0026#34;R_kgDONAZhPA\u0026#34; category = \u0026#34;Announcements\u0026#34; categoryId = \u0026#34;DIC_kwDONAZhPM4CjXiy\u0026#34; mapping = \u0026#34;pathname\u0026#34; lightTheme = \u0026#34;\u0026#34; darkTheme = \u0026#34;\u0026#34; reactionsEnabled = 1 emitMetadata = 0 ","date":"2024-10-17T13:39:46+08:00","permalink":"https://blog.zlaaa.top/p/how-to-use-hugo/","title":"使用 Hugo Stack 和 GitHub Pages/Actions 搭建博客"},{"content":"欢迎来到我的博客！在这里，我将分享我的编程经验、技术心得以及生活中的点滴。希望你能在这里找到有用的信息，并与我一起成长。感谢你的访问，祝你阅读愉快！\n","date":"2024-10-15T17:06:46+08:00","permalink":"https://blog.zlaaa.top/p/welcome-to-my-blog/","title":"欢迎来到我的博客"}]